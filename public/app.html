<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC Prediction System</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root{--bg:#08090d;--bg2:#0e1017;--sf:#13151c;--sf2:#181b24;--sf3:#1e222e;--bd:rgba(255,255,255,.06);--bdh:rgba(255,255,255,.1);--tx:#edeef2;--tx2:#a0a5b8;--tx3:#5d6277;--btc:#f7931a;--btcs:rgba(247,147,26,.1);--btcm:rgba(247,147,26,.2);--up:#00dc82;--ups:rgba(0,220,130,.1);--upm:rgba(0,220,130,.18);--dn:#ff4757;--dns:rgba(255,71,87,.1);--dnm:rgba(255,71,87,.18);--bl:#636bff;--bls:rgba(99,107,255,.1);--r:12px;--rs:8px}
        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:'Outfit',sans-serif;background:var(--bg);color:var(--tx);min-height:100vh;-webkit-font-smoothing:antialiased;overflow-x:hidden}
        .shell{max-width:1320px;margin:0 auto;padding:20px 20px 60px}

        /* NAV */
        .nav{display:flex;align-items:center;gap:14px;padding:14px 0 20px;border-bottom:1px solid var(--bd);margin-bottom:22px}
        .nav-mark{width:36px;height:36px;border-radius:10px;background:linear-gradient(140deg,var(--btc),#e07c0e);display:grid;place-items:center;font-size:16px;flex-shrink:0}
        .nav-text h1{font-size:1.05em;font-weight:600;letter-spacing:-.01em}
        .nav-text span{font-size:.72em;color:var(--tx3)}
        .nav-right{margin-left:auto;display:flex;gap:6px;align-items:center;flex-wrap:wrap}
        .nav-user{font-size:.8em;color:var(--tx2);padding:0 10px}

        .btn{display:inline-flex;align-items:center;gap:5px;padding:8px 16px;border:none;border-radius:var(--rs);font-family:'Outfit',sans-serif;font-size:.8em;font-weight:500;cursor:pointer;transition:all .15s;white-space:nowrap}
        .btn-go{background:linear-gradient(140deg,var(--btc),#e07c0e);color:#fff;box-shadow:0 2px 10px rgba(247,147,26,.15)}
        .btn-go:hover{box-shadow:0 3px 16px rgba(247,147,26,.22);transform:translateY(-1px)}
        .btn-g{background:var(--sf2);color:var(--tx2);border:1px solid var(--bd)}
        .btn-g:hover{background:var(--sf3);color:var(--tx)}
        .btn-r{background:var(--dns);color:var(--dn);border:1px solid rgba(255,71,87,.12)}
        .btn-r:hover{background:var(--dnm)}
        .btn:disabled{opacity:.35;cursor:not-allowed;transform:none!important}
        .tf-btn{background:var(--sf2);color:var(--tx2);border:1px solid var(--bd);padding:10px 24px;font-size:.85em;font-weight:600;letter-spacing:.02em}
        .tf-btn:hover{background:var(--sf3);color:var(--tx)}
        .tf-active{background:linear-gradient(140deg,var(--btc),#e07c0e)!important;color:#fff!important;border-color:transparent!important;box-shadow:0 2px 12px rgba(247,147,26,.2)}

        .disc{display:flex;align-items:center;gap:8px;padding:9px 15px;background:var(--sf);border:1px solid var(--bd);border-radius:var(--rs);margin-bottom:20px;font-size:.76em;color:var(--tx3);line-height:1.4}
        .disc svg{flex-shrink:0;opacity:.45}

        .card{background:var(--sf);border:1px solid var(--bd);border-radius:var(--r);padding:22px;margin-bottom:14px;transition:border-color .2s}
        .card:hover{border-color:var(--bdh)}
        .ct{font-size:.68em;font-weight:600;text-transform:uppercase;letter-spacing:.1em;color:var(--tx3);margin-bottom:16px}

        .g2{display:grid;grid-template-columns:1fr 1fr;gap:14px}
        .g3{display:grid;grid-template-columns:repeat(3,1fr);gap:14px}
        .g6{display:grid;grid-template-columns:repeat(auto-fill,minmax(145px,1fr));gap:10px}
        @media(max-width:768px){.g2,.g3{grid-template-columns:1fr}.nav{flex-wrap:wrap}.nav-right{width:100%;justify-content:flex-end}}

        .status{padding:10px 16px;background:var(--sf2);border:1px solid var(--bd);border-radius:var(--rs);text-align:center;font-size:.82em;color:var(--tx2);margin-bottom:12px}
        .mlbar{padding:10px 16px;background:var(--bls);border:1px solid rgba(99,107,255,.1);border-radius:var(--rs);font-size:.76em;color:var(--bl);line-height:1.7}

        .plbl{font-size:.68em;text-transform:uppercase;letter-spacing:.08em;color:var(--tx3);margin-bottom:4px}
        .pbig{font-family:'JetBrains Mono',monospace;font-size:2.1em;font-weight:700;letter-spacing:-.03em}
        .psub{font-size:.72em;color:var(--tx3);margin-top:3px}

        .vs{background:var(--sf2);border:1px solid var(--bd);border-radius:var(--rs);padding:14px;text-align:center;margin-top:14px}
        .vsl{font-size:.66em;text-transform:uppercase;letter-spacing:.08em;color:var(--tx3);margin-bottom:5px}
        .vsv{font-family:'JetBrains Mono',monospace;font-size:1.1em;font-weight:600}

        .pred{padding:20px;border-radius:var(--r);text-align:center}
        .pred-up{background:var(--ups);border:1px solid rgba(0,220,130,.12)}
        .pred-dn{background:var(--dns);border:1px solid rgba(255,71,87,.12)}
        .pred-nu{background:var(--sf2);border:1px solid var(--bd)}
        .pred-info{background:var(--btcs);border:1px solid rgba(247,147,26,.1)}
        .pred h3{font-size:.74em;font-weight:500;color:var(--tx2);margin-bottom:8px}
        .pred .val{font-family:'JetBrains Mono',monospace;font-size:1.4em;font-weight:700}
        .pred .conf{font-size:.76em;color:var(--tx2);margin-top:6px}

        .cftrack{width:100%;height:6px;background:var(--sf3);border-radius:3px;overflow:hidden;margin:12px 0 4px}
        .cffill{height:100%;border-radius:3px;background:linear-gradient(90deg,var(--up),#00b86e);transition:width .5s}
        .cflbl{text-align:right;font-family:'JetBrains Mono',monospace;font-size:.72em;color:var(--tx3)}
        .skipmsg{background:var(--sf2);border:1px solid var(--bd);border-radius:var(--rs);padding:10px;text-align:center;font-size:.78em;color:var(--tx3);margin-top:10px;display:none}

        .mc{background:var(--sf2);border:1px solid var(--bd);border-radius:var(--rs);padding:15px}
        .mc h4{font-size:.68em;text-transform:uppercase;letter-spacing:.08em;color:var(--tx3);margin-bottom:8px}
        .mc .mp{font-family:'JetBrains Mono',monospace;font-weight:700;font-size:.88em}
        .mc .mcc{font-size:.75em;color:var(--tx3);margin-top:3px}

        .pat{background:var(--btcs);border:1px solid rgba(247,147,26,.12);border-radius:var(--rs);padding:10px 16px;font-size:.82em;color:var(--btc);margin-top:10px;display:none;font-weight:500}
        .sigw{background:var(--sf2);border-radius:var(--rs);padding:16px;margin-top:14px}
        .sigw h3{font-size:.68em;font-weight:600;text-transform:uppercase;letter-spacing:.08em;color:var(--tx3);margin-bottom:10px}
        .sig{display:flex;justify-content:space-between;align-items:center;padding:8px 11px;margin:4px 0;background:var(--sf);border-radius:6px;font-size:.78em;border-left:3px solid var(--bd)}
        .sig-u{border-left-color:var(--up)}.sig-d{border-left-color:var(--dn)}

        .chip{background:var(--sf2);border:1px solid var(--bd);border-radius:var(--rs);padding:11px 13px}
        .chip .cl{font-size:.64em;text-transform:uppercase;letter-spacing:.07em;color:var(--tx3);margin-bottom:4px}
        .chip .cv{font-family:'JetBrains Mono',monospace;font-size:.86em;font-weight:600}
        .echip{background:var(--btcs);border:1px solid rgba(247,147,26,.08);border-radius:var(--rs);padding:11px 13px}
        .echip .cl{font-size:.64em;text-transform:uppercase;letter-spacing:.07em;color:rgba(247,147,26,.5);margin-bottom:4px}
        .echip .cv{font-family:'JetBrains Mono',monospace;font-size:.86em;font-weight:600;color:var(--btc)}

        .sbox{background:var(--sf2);border:1px solid var(--bd);border-radius:var(--rs);padding:14px;text-align:center}
        .sbox .sl{font-size:.64em;text-transform:uppercase;letter-spacing:.07em;color:var(--tx3);margin-bottom:5px}
        .sbox .sv{font-family:'JetBrains Mono',monospace;font-size:1.3em;font-weight:700;color:var(--btc)}

        .perf{background:var(--sf2);border-radius:var(--rs);padding:14px;margin-top:14px}
        .perf h3{font-size:.68em;font-weight:600;text-transform:uppercase;letter-spacing:.08em;color:var(--tx3);margin-bottom:10px}
        .prow{display:flex;justify-content:space-between;align-items:center;padding:6px 10px;background:var(--sf);margin:3px 0;border-radius:5px;font-size:.78em}

        .hist{max-height:330px;overflow-y:auto;margin-top:10px}
        .hist::-webkit-scrollbar{width:3px}
        .hist::-webkit-scrollbar-thumb{background:var(--bd);border-radius:2px}
        .hitem{padding:11px;border-bottom:1px solid var(--bd);font-size:.8em}
        .hitem:last-child{border-bottom:none}
        .correct{color:var(--up);font-weight:600}.incorrect{color:var(--dn);font-weight:600}
    </style>
</head>
<body>
<div class="shell">
    <nav class="nav">
        <div class="nav-mark">&#8383;</div>
        <div class="nav-text"><h1>BTC Prediction</h1><span>5-Minute Forecasts &middot; Chainlink BTC/USD (Polymarket Source)</span></div>
        <div class="nav-right">
            <span class="nav-user" id="userGreeting"></span>
            <button class="btn btn-go" id="startBtn" onclick="startPredictions()">Start</button>
            <button class="btn btn-g" id="stopBtn" onclick="stopPredictions()" disabled>Stop</button>
            <button class="btn btn-g" onclick="saveProgress()">Save</button>
            <button class="btn btn-r" onclick="resetStats()">Reset</button>
            <button class="btn btn-g" onclick="logout()">Log out</button>
        </div>
    </nav>

    <div class="disc">
        <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>
        Predictions are not 100% accurate and can make mistakes. Use as a reference, not financial advice. Progress auto-saves.
    </div>

    <div class="card">
        <div class="ct">Market Status</div>
        <div class="status" id="status">Ready &mdash; Click Start</div>
        <div class="mlbar" id="mlStatus">Ensemble: Initializing &middot; LSTM: Not trained &middot; Pattern Recognition: Active</div>
        <div class="g2" style="margin-top:16px">
            <div style="text-align:center"><div class="plbl">Price to Beat</div><div class="pbig" id="priceToBeat" style="color:var(--tx2)">--</div><div class="psub" id="ptbLabel">Set at 5-minute mark</div></div>
            <div style="text-align:center"><div class="plbl">Current Price</div><div class="pbig" id="currentPrice" style="color:var(--btc)">--</div><div class="psub" id="lastUpdate">--</div></div>
        </div>
        <div class="vs"><div class="vsl">Current vs Target</div><div class="vsv" id="vsComparison">--</div></div>
    </div>

    <div class="card">
        <div class="ct">Prediction &amp; Confidence</div>
        <div class="g2">
            <div class="pred pred-nu" id="predictionDisplay"><h3>Ensemble Prediction</h3><div class="val" id="predictionValue">--</div><div class="conf" id="predictionConfidence">--</div><div style="margin-top:6px;font-size:.75em;color:var(--tx3)" id="predictionDetails">--</div></div>
            <div class="pred pred-info"><h3>Next Check</h3><div style="font-family:'JetBrains Mono',monospace;font-size:1.25em;font-weight:700;color:var(--btc);margin:8px 0" id="nextCheckTime">--</div><div style="font-size:.73em;color:var(--tx2);line-height:1.8">3 ML Models &middot; 15+ Indicators<br>Sentiment &middot; Pattern Recognition</div></div>
        </div>
        <div><div class="cflbl"><span id="confPercent">0%</span></div><div class="cftrack"><div class="cffill" id="confidenceMeter" style="width:0%"></div></div></div>
        <div class="g3" style="margin-top:12px">
            <div class="mc"><h4>LSTM</h4><div class="mp" id="model1Pred">--</div><div class="mcc" id="model1Conf">--%</div></div>
            <div class="mc"><h4>Technical</h4><div class="mp" id="model2Pred">--</div><div class="mcc" id="model2Conf">--%</div></div>
            <div class="mc"><h4>Hybrid</h4><div class="mp" id="model3Pred">--</div><div class="mcc" id="model3Conf">--%</div></div>
        </div>
        <div class="pat" id="patternSection"><span id="patternName"></span></div>
        <div class="sigw"><h3>Signal Breakdown</h3><div id="signalList" style="color:var(--tx3);font-size:.8em">Waiting&hellip;</div></div>
    </div>

    <div class="card">
        <div class="ct">Market Sentiment</div>
        <div class="g6">
            <div class="echip"><div class="cl">Fear &amp; Greed</div><div class="cv" id="fearGreed">--</div></div>
            <div class="echip"><div class="cl">Sentiment</div><div class="cv" id="sentiment">--</div></div>
            <div class="echip"><div class="cl">BTC Dominance</div><div class="cv" id="btcDominance">--</div></div>
            <div class="echip"><div class="cl">Funding Rate</div><div class="cv" id="fundingRate">--</div></div>
            <div class="echip"><div class="cl">Exchange Flow</div><div class="cv" id="exchangeFlow">--</div></div>
            <div class="echip"><div class="cl">Whale Activity</div><div class="cv" id="whaleActivity">--</div></div>
        </div>
    </div>

    <div class="card">
        <div class="ct">Technical Indicators</div>
        <div class="g6">
            <div class="chip"><div class="cl">SMA 5</div><div class="cv" id="sma5">--</div></div>
            <div class="chip"><div class="cl">SMA 10</div><div class="cv" id="sma10">--</div></div>
            <div class="chip"><div class="cl">SMA 20</div><div class="cv" id="sma20">--</div></div>
            <div class="chip"><div class="cl">EMA 12</div><div class="cv" id="ema12">--</div></div>
            <div class="chip"><div class="cl">RSI (14)</div><div class="cv" id="rsi">--</div></div>
            <div class="chip"><div class="cl">Stochastic</div><div class="cv" id="stochastic">--</div></div>
            <div class="chip"><div class="cl">BB Upper</div><div class="cv" id="bbUpper">--</div></div>
            <div class="chip"><div class="cl">BB Lower</div><div class="cv" id="bbLower">--</div></div>
            <div class="chip"><div class="cl">MACD</div><div class="cv" id="macd">--</div></div>
            <div class="chip"><div class="cl">ATR</div><div class="cv" id="atr">--</div></div>
            <div class="chip"><div class="cl">Volume</div><div class="cv" id="volumeTrend">--</div></div>
            <div class="chip"><div class="cl">Momentum</div><div class="cv" id="momentum">--</div></div>
        </div>
    </div>

    <div class="card">
        <div class="ct">Performance</div>
        <div class="g6" style="grid-template-columns:repeat(auto-fill,minmax(115px,1fr))">
            <div class="sbox"><div class="sl">Total</div><div class="sv" id="totalPredictions">0</div></div>
            <div class="sbox"><div class="sl">Correct</div><div class="sv" style="color:var(--up)" id="correctPredictions">0</div></div>
            <div class="sbox"><div class="sl">Accuracy</div><div class="sv" id="accuracyRate">--%</div></div>
            <div class="sbox"><div class="sl">High-Conf</div><div class="sv" id="highConfAccuracy">--%</div></div>
            <div class="sbox"><div class="sl">Streak</div><div class="sv" id="winStreak">0</div></div>
            <div class="sbox"><div class="sl">Skipped</div><div class="sv" style="color:var(--tx3)" id="skippedCount">0</div></div>
        </div>
        <div class="perf"><h3>Signal Performance</h3><div id="signalPerformance" style="color:var(--tx3);text-align:center;font-size:.8em">Collecting data&hellip;</div></div>
        <div style="margin-top:14px"><div class="ct">History</div><div class="hist" id="history"><div style="text-align:center;padding:16px;color:var(--tx3);font-size:.8em">No predictions yet</div></div></div>
    </div>

    <!-- HOW IT WORKS -->
    <div class="card">
        <div class="ct">How Our Predictions Work</div>
        <div style="font-size:.85em;color:var(--tx2);line-height:1.85">
            <p style="margin-bottom:14px">Our system loads <strong style="color:var(--tx)">200 historical candlesticks</strong> from Binance on startup, then combines <strong style="color:var(--tx)">15+ trading strategies</strong> with 3 ML models and real-time market data.</p>

            <div style="background:var(--sf2);border-radius:var(--rs);padding:16px;margin-bottom:12px">
                <div style="color:var(--btc);font-weight:600;font-size:.82em;text-transform:uppercase;letter-spacing:.06em;margin-bottom:8px">&#9881; Historical Data Engine</div>
                <p><strong style="color:var(--tx)">200 1-Min Candles</strong> &mdash; Full OHLCV data loaded on startup from Binance, giving indicators real history immediately. No warmup needed.</p>
                <p style="margin-top:8px"><strong style="color:var(--tx)">100 5-Min Candles</strong> &mdash; Bigger-picture context for trend analysis and VWAP calculations. Refreshed every 60 seconds.</p>
            </div>

            <div style="background:var(--sf2);border-radius:var(--rs);padding:16px;margin-bottom:12px">
                <div style="color:var(--up);font-weight:600;font-size:.82em;text-transform:uppercase;letter-spacing:.06em;margin-bottom:8px">&#9889; 15+ Trading Strategies</div>
                <p><strong style="color:var(--tx)">VWAP</strong> &mdash; Volume Weighted Average Price, used by institutions. Price above VWAP = bullish.</p>
                <p style="margin-top:8px"><strong style="color:var(--tx)">EMA Ribbon (8/13/21/55)</strong> &mdash; When EMAs stack in order, strong trend confirmed.</p>
                <p style="margin-top:8px"><strong style="color:var(--tx)">Mean Reversion (Z-Score)</strong> &mdash; Detects overbought/oversold using statistical deviation. Key for 5-min windows.</p>
                <p style="margin-top:8px"><strong style="color:var(--tx)">ADX Trend Strength</strong> &mdash; Measures trend intensity. >25 = strong trend, <25 = ranging.</p>
                <p style="margin-top:8px"><strong style="color:var(--tx)">Williams %R, OBV, ROC, Stochastic, Bollinger Squeeze, Support/Resistance</strong> &mdash; Multiple confirming indicators reduce false signals.</p>
                <p style="margin-top:8px"><strong style="color:var(--tx)">Candlestick Patterns</strong> &mdash; Doji, Hammer, Shooting Star, Engulfing patterns from real OHLC candle data.</p>
                <p style="margin-top:8px"><strong style="color:var(--tx)">Buy/Sell Pressure</strong> &mdash; Real taker buy/sell ratio from Binance 24hr data.</p>
                <p style="margin-top:8px"><strong style="color:var(--tx)">Contrarian Indicators</strong> &mdash; Fear &amp; Greed and Funding Rate used as contrarian signals (extreme fear = buy, extreme greed = sell).</p>
            </div>

            <div style="background:var(--sf2);border-radius:var(--rs);padding:16px;margin-bottom:12px">
                <div style="color:var(--bl);font-weight:600;font-size:.82em;text-transform:uppercase;letter-spacing:.06em;margin-bottom:8px">&#128202; ML Ensemble</div>
                <p><strong style="color:var(--tx)">LSTM Neural Network</strong> &mdash; Sequential pattern analysis on 15-feature vectors.</p>
                <p style="margin-top:8px"><strong style="color:var(--tx)">Technical &amp; Hybrid Models</strong> &mdash; Dense networks trained on live prediction results with adaptive weight optimization.</p>
            </div>

            <div style="background:var(--sf2);border-radius:var(--rs);padding:16px">
                <div style="color:var(--btc);font-weight:600;font-size:.82em;text-transform:uppercase;letter-spacing:.06em;margin-bottom:8px">&#127919; Adaptive Signal Weighting</div>
                <p>Each strategy's weight adjusts based on real accuracy. <strong style="color:var(--tx)">High-performing signals gain influence</strong>, underperformers lose weight. System self-improves over every 5-minute cycle.</p>
            </div>
        </div>
    </div>

</div>

<script>
// ═══ AUTH CHECK ═══
async function checkAuth(){
    try{const r=await fetch('/api/me');if(!r.ok){window.location.href='/';return}const d=await r.json();document.getElementById('userGreeting').textContent=d.username}catch(e){window.location.href='/'}
}
async function logout(){
    await fetch('/api/logout',{method:'POST'});window.location.href='/';
}
checkAuth();
setInterval(async () => {
  try {
    const r = await fetch('/api/me');
    if (!r.ok) {
      const data = await r.json().catch(() => ({}));
      if (data.error && data.error.includes('Someone else')) {
        alert('You have been logged out because someone else logged in with your access code. If this wasn\'t you, get a new code with /getaccess in Discord.');
      }
      window.location.href = '/';
    }
  } catch (e) { }
}, 10000);

// ═══ STATE ═══
let selectedTimeframe=5; // 5, 15, or 60 minutes
let priceHistory=[],predictionHistory=[],updateInterval=null,checkInterval=null;
let isRunning=false;
let lstmModel=null,technicalModel=null,hybridModel=null,modelsTraining=false,trainingData=[];
let signalWeights={sma:2,rsi:2.5,bollinger:2,macd:2,volume:1.5,momentum:1.5,pattern:2.5,sentiment:1.8,lstm:3,technical:2.5,hybrid:2.5};
let signalPerformance={};
let stats={total:0,correct:0,currentStreak:0,skipped:0,highConfPredictions:0,highConfCorrect:0};
let externalData={fearGreed:50,sentiment:'NEUTRAL',btcDominance:50,fundingRate:0,exchangeFlow:'NEUTRAL',whaleActivity:'LOW'};

// Per-timeframe market state
let markets={
  5:{priceToBeat:null,currentSlot:null,currentPrediction:null},
  15:{priceToBeat:null,currentSlot:null,currentPrediction:null},
  60:{priceToBeat:null,currentSlot:null,currentPrediction:null}
};

// Get the current time slot for a timeframe
// e.g. for 5min at 14:37 → slot is "14:35", at 14:40 → slot is "14:40"
function getSlot(tf,date){
  const d=date||new Date();
  const totalMins=d.getHours()*60+d.getMinutes();
  const slotMins=Math.floor(totalMins/tf)*tf;
  return slotMins; // unique number per slot
}

// Get the end time of the current slot (= when next slot starts)
function getSlotEnd(tf,date){
  const d=date||new Date();
  const totalMins=d.getHours()*60+d.getMinutes();
  const slotMins=Math.floor(totalMins/tf)*tf;
  const nextSlotMins=slotMins+tf;
  const end=new Date(d);
  end.setHours(Math.floor(nextSlotMins/60),nextSlotMins%60,0,0);
  if(nextSlotMins>=1440){end.setDate(end.getDate()+1);end.setHours(0,0,0,0)}
  return end;
}

function getActiveMarket(){return markets[selectedTimeframe]}

function setTimeframe(tf){
  selectedTimeframe=tf;
  document.querySelectorAll('.tf-btn').forEach(b=>b.classList.remove('tf-active'));
  document.getElementById('tf'+tf).classList.add('tf-active');
  const labels={5:'5-minute',15:'15-minute',60:'1-hour'};
  document.getElementById('ptbLabel').textContent='Set at '+labels[tf]+' mark';
  const m=getActiveMarket();
  if(m.priceToBeat){
    document.getElementById('priceToBeat').textContent='$'+m.priceToBeat.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2});
    // Immediately calculate vs comparison with latest price
    if(latestBtcPrice){
      const d=latestBtcPrice-m.priceToBeat,p=(d/m.priceToBeat*100).toFixed(3);
      document.getElementById('vsComparison').innerHTML=d>0?'<span style="color:var(--up)">+$'+d.toFixed(2)+' (+'+p+'%)</span>':'<span style="color:var(--dn)">$'+d.toFixed(2)+' ('+p+'%)</span>';
    }
  } else{
    document.getElementById('priceToBeat').textContent='--';
    document.getElementById('vsComparison').textContent='--';
  }
  if(isRunning)updateCountdown();
}

// ═══ SAVE/LOAD ═══
function saveProgress(){try{localStorage.setItem('btcPred',JSON.stringify({predictionHistory:predictionHistory.slice(0,50),trainingData:trainingData.slice(-100),stats,signalPerformance,signalWeights,lastSaved:Date.now()}))}catch(e){}}
function loadProgress(){try{const s=localStorage.getItem('btcPred');if(!s)return false;const d=JSON.parse(s);if((Date.now()-d.lastSaved)/36e5>24)return false;priceHistory=d.priceHistory||[];predictionHistory=d.predictionHistory||[];trainingData=d.trainingData||[];stats=d.stats||stats;signalPerformance=d.signalPerformance||{};signalWeights=d.signalWeights||signalWeights;
// Don't restore priceToBeat — always get fresh from market. Only restore stats/history.
updateStats();updateHistoryDisplay();updateSignalPerformance();document.getElementById('mlStatus').innerHTML='Ensemble: <strong style="color:var(--up)">ACTIVE</strong> &middot; All models online &middot; Pattern Recognition: Active';return true}catch(e){return false}}
setInterval(saveProgress,3e5);window.addEventListener('beforeunload',saveProgress);

// ═══ UTILITY ═══
function fmt(d){return d.toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit',hour12:true})}
let btcWs=null,latestBtcPrice=null;
let polyWs=null,latestChainlinkPrice=null;

// PRIMARY: Polymarket RTDS WebSocket (Chainlink BTC/USD - exact Polymarket price)
function connectPolyWs(){
  try{
    polyWs=new WebSocket('wss://ws-live-data.polymarket.com');
    polyWs.onopen=function(){
      // Subscribe to Chainlink BTC/USD (what Polymarket uses for settlement)
      polyWs.send(JSON.stringify({
        action:'subscribe',
        subscriptions:[{topic:'crypto_prices_chainlink',type:'*',filters:'{"symbol":"btc/usd"}'}]
      }));
      // Also subscribe to Binance BTC/USDT for backup
      polyWs.send(JSON.stringify({
        action:'subscribe',
        subscriptions:[{topic:'crypto_prices',type:'update',filters:'btcusdt'}]
      }));
      console.log('Connected to Polymarket RTDS');
    };
    polyWs.onmessage=function(e){
      try{
        const d=JSON.parse(e.data);
        if(d.topic==='crypto_prices_chainlink'&&d.payload&&d.payload.symbol==='btc/usd'){
          latestChainlinkPrice=d.payload.value;
          latestBtcPrice=d.payload.value; // Use Chainlink as primary
        }else if(d.topic==='crypto_prices'&&d.payload&&d.payload.symbol==='btcusdt'){
          if(!latestChainlinkPrice)latestBtcPrice=d.payload.value; // Fallback to Binance
        }
      }catch(ex){}
    };
    // Send pings every 5 seconds to keep alive
    let pingInterval=setInterval(()=>{
      if(polyWs.readyState===1)polyWs.send('PING');
      else{clearInterval(pingInterval)}
    },5000);
    polyWs.onclose=function(){clearInterval(pingInterval);setTimeout(connectPolyWs,3000)};
    polyWs.onerror=function(){polyWs.close()};
  }catch(e){setTimeout(connectPolyWs,5000)}
}

// BACKUP: Binance WebSocket (in case Polymarket RTDS fails)
function connectBtcWs(){try{btcWs=new WebSocket('wss://stream.binance.com:9443/ws/btcusdt@trade');btcWs.onmessage=function(e){const d=JSON.parse(e.data);if(!latestChainlinkPrice)latestBtcPrice=parseFloat(d.p)};btcWs.onclose=function(){setTimeout(connectBtcWs,3000)};btcWs.onerror=function(){btcWs.close()}}catch(e){setTimeout(connectBtcWs,5000)}}
connectPolyWs();
connectBtcWs();
async function fetchBTCPrice(){if(latestBtcPrice)return latestBtcPrice;try{const r=await fetch('https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT');const d=await r.json();return parseFloat(d.price)}catch(e){return simPrice()}}
let lsp=68360,lsv=1e6;
function simPrice(){lsp+=(Math.random()-.5)*100+(Math.random()-.5)*20;return lsp}
let realVolume=0;
async function fetchVolume(){try{const r=await fetch('https://api.binance.com/api/v3/ticker/24hr?symbol=BTCUSDT');const d=await r.json();realVolume=parseFloat(d.quoteVolume);return parseFloat(d.volume)}catch(e){return 1e6}}
function getVolume(){return realVolume||1e6}

// ═══ HISTORICAL DATA LOADER ═══
let historicalCandles=[];
async function loadHistoricalData(){
  try{
    document.getElementById('mlStatus').innerHTML='Ensemble: <strong style="color:var(--btc)">LOADING</strong> &middot; Fetching 200 candles from Binance...';
    // Fetch 200 1-minute candles
    const r=await fetch('https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m&limit=200');
    const raw=await r.json();
    historicalCandles=raw.map(c=>({
      time:c[0],open:parseFloat(c[1]),high:parseFloat(c[2]),low:parseFloat(c[3]),
      close:parseFloat(c[4]),volume:parseFloat(c[5]),trades:c[8]
    }));
    // Pre-populate priceHistory from candles
    historicalCandles.forEach(c=>{
      priceHistory.push({price:c.close,volume:c.volume,timestamp:c.time,
        open:c.open,high:c.high,low:c.low,trades:c.trades});
    });
    if(priceHistory.length>300)priceHistory=priceHistory.slice(-300);
    // Also fetch 5-minute candles for bigger picture
    const r5=await fetch('https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=5m&limit=100');
    const raw5=await r5.json();
    window.candles5m=raw5.map(c=>({
      time:c[0],open:parseFloat(c[1]),high:parseFloat(c[2]),low:parseFloat(c[3]),
      close:parseFloat(c[4]),volume:parseFloat(c[5])
    }));
    // Fetch buy/sell ratio
    await fetchTakerVolume();
    // Fetch order book, open interest, trade flow, long/short ratio
    await fetchOrderBook();
    await fetchOpenInterest();
    await fetchRecentTrades();
    await fetchLongShortRatio();
    document.getElementById('mlStatus').innerHTML='Ensemble: <strong style="color:var(--up)">ACTIVE</strong> &middot; 200 candles + order book loaded &middot; 21 strategies online';
    return true;
  }catch(e){
    console.error('Failed to load historical:',e);
    document.getElementById('mlStatus').innerHTML='Ensemble: <strong style="color:var(--up)">ACTIVE</strong> &middot; Live mode &middot; All models online';
    return false;
  }
}

// ═══ REAL BUY/SELL PRESSURE ═══
let takerBuyRatio=0.5;
async function fetchTakerVolume(){
  try{
    const r=await fetch('https://api.binance.com/api/v3/ticker/24hr?symbol=BTCUSDT');
    const d=await r.json();
    // Approximate from price movement and volume
    const change=parseFloat(d.priceChangePercent);
    // Taker buy ratio: >0.5 means more buying pressure
    takerBuyRatio=0.5+Math.tanh(change/3)*0.3;
  }catch(e){}
}

// ═══ ADVANCED INDICATORS ═══
function vwap(candles){
  if(!candles||candles.length<10)return null;
  let cumVol=0,cumPV=0;
  // Use last 30 candles for intraday VWAP
  const slice=candles.slice(-30);
  slice.forEach(c=>{
    const tp=(c.high+c.low+c.close)/3;
    cumPV+=tp*(c.volume||1);
    cumVol+=(c.volume||1);
  });
  return cumVol?cumPV/cumVol:null;
}

function emaRibbon(prices){
  if(prices.length<55)return null;
  const e8=ema(prices,8),e13=ema(prices,13),e21=ema(prices,21),e55=ema(prices,55);
  if(!e8||!e13||!e21||!e55)return null;
  const bullish=e8>e13&&e13>e21&&e21>e55;
  const bearish=e8<e13&&e13<e21&&e21<e55;
  const spread=Math.abs(e8-e55)/e55*100;
  return{bullish,bearish,spread,e8,e13,e21,e55};
}

function roc(prices,period){
  if(prices.length<period+1)return null;
  return(prices[prices.length-1]-prices[prices.length-1-period])/prices[prices.length-1-period]*100;
}

function obv(prices,volumes){
  if(prices.length<2||volumes.length<2)return null;
  let o=0;
  for(let i=1;i<prices.length;i++){
    if(prices[i]>prices[i-1])o+=volumes[i]||1;
    else if(prices[i]<prices[i-1])o-=(volumes[i]||1);
  }
  return o;
}

function williamsR(prices,period=14){
  if(prices.length<period)return null;
  const s=prices.slice(-period),h=Math.max(...s),l=Math.min(...s);
  if(h===l)return-50;
  return((h-prices[prices.length-1])/(h-l))*-100;
}

function adx(prices,period=14){
  if(prices.length<period*2)return null;
  let pDM=0,nDM=0,tr=0;
  for(let i=prices.length-period;i<prices.length;i++){
    const diff=prices[i]-prices[i-1];
    if(diff>0)pDM+=diff;else nDM+=Math.abs(diff);
    tr+=Math.abs(diff);
  }
  if(tr===0)return{adx:0,trend:'NONE'};
  const pDI=pDM/tr*100,nDI=nDM/tr*100;
  const dx=Math.abs(pDI-nDI)/(pDI+nDI)*100;
  return{adx:dx,pDI,nDI,trend:dx>25?(pDI>nDI?'STRONG UP':'STRONG DOWN'):'RANGING'};
}

function meanReversion(prices,period=20){
  if(prices.length<period)return null;
  const avg=sma(prices,period),cur=prices[prices.length-1];
  const dev=(cur-avg)/avg*100;
  // Z-score
  const slice=prices.slice(-period);
  const std=Math.sqrt(slice.reduce((s,p)=>s+Math.pow(p-avg,2),0)/period);
  const zscore=std?(cur-avg)/std:0;
  return{deviation:dev,zscore,signal:zscore>2?'OVERBOUGHT':zscore<-2?'OVERSOLD':zscore>1?'HIGH':zscore<-1?'LOW':'NEUTRAL'};
}

function supportResistance(prices){
  if(prices.length<50)return null;
  const recent=prices.slice(-50);
  // Find local highs and lows
  const highs=[],lows=[];
  for(let i=2;i<recent.length-2;i++){
    if(recent[i]>recent[i-1]&&recent[i]>recent[i-2]&&recent[i]>recent[i+1]&&recent[i]>recent[i+2])highs.push(recent[i]);
    if(recent[i]<recent[i-1]&&recent[i]<recent[i-2]&&recent[i]<recent[i+1]&&recent[i]<recent[i+2])lows.push(recent[i]);
  }
  const cur=prices[prices.length-1];
  const nearestResist=highs.filter(h=>h>cur).sort((a,b)=>a-b)[0]||null;
  const nearestSupport=lows.filter(l=>l<cur).sort((a,b)=>b-a)[0]||null;
  return{resistance:nearestResist,support:nearestSupport,
    distToResist:nearestResist?(nearestResist-cur)/cur*100:null,
    distToSupport:nearestSupport?(cur-nearestSupport)/cur*100:null};
}

function candlePatterns(candles){
  if(!candles||candles.length<3)return null;
  const c=candles.slice(-3);
  const last=c[2],prev=c[1];
  const bodyLast=Math.abs(last.close-last.open);
  const bodyPrev=Math.abs(prev.close-prev.open);
  const rangeLast=last.high-last.low;
  if(bodyLast<rangeLast*0.1&&rangeLast>0)return{pattern:'Doji',signal:'REVERSAL',strength:1.5};
  const lowerWick=Math.min(last.open,last.close)-last.low;
  if(lowerWick>bodyLast*2&&last.close>last.open)return{pattern:'Hammer',signal:'BULLISH',strength:2};
  const upperWick=last.high-Math.max(last.open,last.close);
  if(upperWick>bodyLast*2&&last.close<last.open)return{pattern:'Shooting Star',signal:'BEARISH',strength:2};
  if(last.close>last.open&&prev.close<prev.open&&bodyLast>bodyPrev*1.5)return{pattern:'Bullish Engulfing',signal:'BULLISH',strength:2.5};
  if(last.close<last.open&&prev.close>prev.open&&bodyLast>bodyPrev*1.5)return{pattern:'Bearish Engulfing',signal:'BEARISH',strength:2.5};
  return null;
}

// ═══ ORDER BOOK IMBALANCE (highest impact for 5-min) ═══
let orderBookData={bidTotal:0,askTotal:0,imbalance:0,bigBidWalls:[],bigAskWalls:[],spread:0,bidDepth5:[],askDepth5:[]};
let orderBookHistory=[]; // Track last N snapshots for recency weighting
async function fetchOrderBook(){
  try{
    const r=await fetch('https://api.binance.com/api/v3/depth?symbol=BTCUSDT&limit=20');
    const d=await r.json();
    const bids=d.bids.map(b=>({price:parseFloat(b[0]),qty:parseFloat(b[1])}));
    const asks=d.asks.map(a=>({price:parseFloat(a[0]),qty:parseFloat(a[1])}));
    const bidTotal=bids.reduce((s,b)=>s+b.qty*b.price,0);
    const askTotal=asks.reduce((s,a)=>s+a.qty*a.price,0);
    const imbalance=(bidTotal-askTotal)/(bidTotal+askTotal);
    const avgBid=bidTotal/bids.length;
    const avgAsk=askTotal/asks.length;
    const bigBidWalls=bids.filter(b=>b.qty*b.price>avgBid*3);
    const bigAskWalls=asks.filter(a=>a.qty*a.price>avgAsk*3);
    const spread=asks[0].price-bids[0].price;
    const bidDepth5=bids.slice(0,5).reduce((s,b)=>s+b.qty*b.price,0);
    const askDepth5=asks.slice(0,5).reduce((s,a)=>s+a.qty*a.price,0);
    const nearImbalance=(bidDepth5-askDepth5)/(bidDepth5+askDepth5);
    orderBookData={bidTotal,askTotal,imbalance,bigBidWalls,bigAskWalls,spread,bidDepth5,askDepth5,nearImbalance};
    // Track history for recency analysis
    orderBookHistory.push({imbalance,nearImbalance,timestamp:Date.now()});
    if(orderBookHistory.length>12)orderBookHistory.shift(); // Keep last ~60 sec (12 x 5s)
    return orderBookData;
  }catch(e){return null}
}

// Order book momentum: is the imbalance GROWING or SHRINKING?
function getOrderBookMomentum(){
  if(orderBookHistory.length<3)return 0;
  const recent=orderBookHistory.slice(-3).reduce((s,h)=>s+h.nearImbalance,0)/3;
  const older=orderBookHistory.slice(0,Math.min(3,orderBookHistory.length-3)).reduce((s,h)=>s+h.nearImbalance,0)/Math.min(3,orderBookHistory.length-3);
  return recent-older; // Positive = bids growing, negative = asks growing
}

// Trade flow history for momentum
let tradeFlowHistory=[];
function getTradeFlowMomentum(){
  if(tradeFlowHistory.length<3)return 0;
  const recent=tradeFlowHistory.slice(-3).reduce((s,r)=>s+r,0)/3;
  const older=tradeFlowHistory.slice(0,Math.min(3,tradeFlowHistory.length-3)).reduce((s,r)=>s+r,0)/Math.min(3,tradeFlowHistory.length-3);
  return recent-older;
}

// ═══ REGIME DETECTION (trending vs ranging) ═══
function detectRegime(prices){
  if(prices.length<50)return'UNKNOWN';
  const adxVal=adx(prices);
  const atrVal=atr(prices);
  const avgPrice=sma(prices,20);
  const volatility=atrVal&&avgPrice?(atrVal/avgPrice*100):0;
  // ADX > 25 and directional = trending
  if(adxVal&&adxVal.adx>25)return adxVal.pDI>adxVal.nDI?'TRENDING_UP':'TRENDING_DOWN';
  // Low ADX + low volatility = ranging
  if(adxVal&&adxVal.adx<20&&volatility<0.3)return'RANGING';
  // Medium = choppy
  return'CHOPPY';
}

// ═══ OPEN INTEREST (futures positioning) ═══
let openInterestData={current:0,change:0,history:[]};
async function fetchOpenInterest(){
  try{
    const r=await fetch('https://fapi.binance.com/fapi/v1/openInterest?symbol=BTCUSDT');
    const d=await r.json();
    const current=parseFloat(d.openInterest);
    const prev=openInterestData.current;
    openInterestData.history.push(current);
    if(openInterestData.history.length>30)openInterestData.history.shift();
    openInterestData.current=current;
    openInterestData.change=prev?((current-prev)/prev*100):0;
    return openInterestData;
  }catch(e){return null}
}

// ═══ RECENT TRADES FLOW (aggressor analysis) ═══
let tradeFlowData={buyVolume:0,sellVolume:0,buyRatio:0.5,largeBuys:0,largeSells:0};
async function fetchRecentTrades(){
  try{
    const r=await fetch('https://api.binance.com/api/v3/trades?symbol=BTCUSDT&limit=100');
    const d=await r.json();
    let buyVol=0,sellVol=0,largeBuys=0,largeSells=0;
    const avgQty=d.reduce((s,t)=>s+parseFloat(t.qty),0)/d.length;
    d.forEach(t=>{
      const qty=parseFloat(t.qty);
      const val=qty*parseFloat(t.price);
      if(t.isBuyerMaker){sellVol+=val;if(qty>avgQty*3)largeSells++}
      else{buyVol+=val;if(qty>avgQty*3)largeBuys++}
    });
    tradeFlowData={buyVolume:buyVol,sellVolume:sellVol,
      buyRatio:buyVol/(buyVol+sellVol),largeBuys,largeSells};
    tradeFlowHistory.push(tradeFlowData.buyRatio);
    if(tradeFlowHistory.length>12)tradeFlowHistory.shift();
    return tradeFlowData;
  }catch(e){return null}
}

// ═══ LONG/SHORT RATIO ═══
let longShortRatio=1;
async function fetchLongShortRatio(){
  try{
    const r=await fetch('https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=BTCUSDT&period=5m&limit=5');
    const d=await r.json();
    if(d&&d.length){longShortRatio=parseFloat(d[d.length-1].longShortRatio)}
    return longShortRatio;
  }catch(e){return null}
}

// ═══ PRICE VELOCITY & ACCELERATION ═══
function priceVelocity(prices,period=10){
  if(prices.length<period+1)return null;
  const velocities=[];
  for(let i=prices.length-period;i<prices.length;i++){
    velocities.push(prices[i]-prices[i-1]);
  }
  const velocity=velocities.reduce((a,b)=>a+b,0)/velocities.length;
  // Acceleration = change in velocity
  const recentV=velocities.slice(-5).reduce((a,b)=>a+b,0)/5;
  const olderV=velocities.slice(0,5).reduce((a,b)=>a+b,0)/5;
  const acceleration=recentV-olderV;
  return{velocity,acceleration,
    signal:velocity>0&&acceleration>0?'ACCELERATING UP':
           velocity<0&&acceleration<0?'ACCELERATING DOWN':
           velocity>0&&acceleration<0?'DECELERATING UP':
           velocity<0&&acceleration>0?'DECELERATING DOWN':'NEUTRAL'};
}

// ═══ VOLUME PROFILE (price magnet detection) ═══
function volumeProfile(prices,volumes){
  if(prices.length<50||volumes.length<50)return null;
  // Create price buckets and sum volume at each level
  const min=Math.min(...prices.slice(-50));
  const max=Math.max(...prices.slice(-50));
  const bucketSize=(max-min)/20||1;
  const buckets={};
  for(let i=Math.max(0,prices.length-50);i<prices.length;i++){
    const bucket=Math.floor((prices[i]-min)/bucketSize);
    buckets[bucket]=(buckets[bucket]||0)+(volumes[i]||1);
  }
  // Find the Point of Control (highest volume price level)
  let maxVol=0,pocBucket=0;
  Object.keys(buckets).forEach(k=>{if(buckets[k]>maxVol){maxVol=buckets[k];pocBucket=parseInt(k)}});
  const poc=min+pocBucket*bucketSize+bucketSize/2;
  const cur=prices[prices.length-1];
  return{poc,abovePoc:cur>poc,distToPoc:((cur-poc)/poc*100)};
}

// ═══ INDICATORS ═══
function sma(d,p){if(d.length<p)return null;return d.slice(-p).reduce((a,b)=>a+b,0)/p}
function ema(d,p){if(d.length<p)return null;const k=2/(p+1);let e=sma(d.slice(0,p),p);for(let i=p;i<d.length;i++)e=d[i]*k+e*(1-k);return e}
function rsi(d,p=14){if(d.length<p+1)return null;const c=[];for(let i=1;i<d.length;i++)c.push(d[i]-d[i-1]);const r=c.slice(-p),g=r.filter(x=>x>0),l=r.filter(x=>x<0).map(Math.abs);const ag=g.length?g.reduce((a,b)=>a+b,0)/p:0,al=l.length?l.reduce((a,b)=>a+b,0)/p:0;if(!al)return 100;return 100-100/(1+ag/al)}
function stoch(d,p=14){if(d.length<p)return null;const s=d.slice(-p),h=Math.max(...s),l=Math.min(...s);if(h===l)return 50;return((d[d.length-1]-l)/(h-l))*100}
function bb(d,p=20,sd=2){if(d.length<p)return null;const s=sma(d,p),sl=d.slice(-p),v=sl.reduce((a,x)=>a+Math.pow(x-s,2),0)/p,st=Math.sqrt(v);return{upper:s+st*sd,middle:s,lower:s-st*sd,bw:st*sd*2/s*100}}
function macd(d){if(d.length<26)return null;const m=ema(d,12)-ema(d,26);return{macd:m,signal:m>0?'BULLISH':'BEARISH',strength:Math.abs(m)}}
function atr(d,p=14){if(d.length<p+1)return null;const r=[];for(let i=1;i<Math.min(d.length,p+1);i++)r.push(Math.abs(d[d.length-i]-d[d.length-i-1]));return r.reduce((a,b)=>a+b,0)/r.length}
function vol(d,p=20){if(d.length<p)return null;const r=[];for(let i=1;i<Math.min(d.length,p+1);i++)r.push((d[d.length-i]-d[d.length-i-1])/d[d.length-i-1]);const m=r.reduce((a,b)=>a+b,0)/r.length;return Math.sqrt(r.reduce((s,x)=>s+Math.pow(x-m,2),0)/r.length)*100}

// ═══ PATTERNS ═══
function detectPat(prices){if(prices.length<20)return null;const r=prices.slice(-20),c=prices[prices.length-1],hi=r.filter((p,i)=>i>0&&i<r.length-1&&p>r[i-1]&&p>r[i+1]);if(hi.length>=2&&Math.abs(hi[hi.length-1]-hi[hi.length-2])/hi[0]<.01)return{pattern:'Double Top',signal:'BEARISH',strength:2};const lo=r.filter((p,i)=>i>0&&i<r.length-1&&p<r[i-1]&&p<r[i+1]);if(lo.length>=2&&Math.abs(lo[lo.length-1]-lo[lo.length-2])/lo[0]<.01)return{pattern:'Double Bottom',signal:'BULLISH',strength:2};const sl=(r[r.length-1]-r[0])/r.length;if(sl>0&&hi.length>=2&&Math.abs((hi[hi.length-1]-hi[0])/hi.length)<Math.abs(sl)*.3)return{pattern:'Ascending Triangle',signal:'BULLISH',strength:1.5};const s5=sma(r,5),s20=sma(r,20);if(s5&&s20&&s5>s20&&c>s5)return{pattern:'Strong Uptrend',signal:'BULLISH',strength:1.2};if(s5&&s20&&s5<s20&&c<s5)return{pattern:'Strong Downtrend',signal:'BEARISH',strength:1.2};return null}

// ═══ EXTERNAL ═══
async function fetchFearGreed(){try{const r=await fetch('https://api.alternative.me/fng/');const d=await r.json();return{value:parseInt(d.data[0].value),label:d.data[0].value_classification}}catch(e){return null}}
async function fetchGlobalData(){try{const r=await fetch('https://api.coingecko.com/api/v3/global');const d=await r.json();return{btcDominance:d.data.market_cap_percentage.btc}}catch(e){return null}}
async function fetchFundingRate(){try{const r=await fetch('https://fapi.binance.com/fapi/v1/fundingRate?symbol=BTCUSDT&limit=1');const d=await r.json();return parseFloat(d[0].fundingRate)*100}catch(e){return null}}
async function fetchNetFlow(){try{const r=await fetch('https://api.binance.com/api/v3/ticker/24hr?symbol=BTCUSDT');const d=await r.json();const change=parseFloat(d.priceChangePercent);return change>0.5?'INFLOW':change<-0.5?'OUTFLOW':'NEUTRAL'}catch(e){return null}}
let extUpdateCount=0;
async function updateExt(){
extUpdateCount++;
// HIGH IMPACT: Fetch order book, trades, OI every cycle (every 5 sec)
try{
  await fetchOrderBook();
  await fetchRecentTrades();
}catch(e){}
// MEDIUM: Fetch OI and long/short every 3rd cycle (~15 sec)
if(extUpdateCount%3===1){
  try{await fetchOpenInterest();await fetchLongShortRatio()}catch(e){}
}
// LOW FREQUENCY: Fetch sentiment data every 5th call (~25 sec)
if(extUpdateCount%5===1||extUpdateCount===1){
const fg=await fetchFearGreed();
if(fg){externalData.fearGreed=fg.value;externalData.sentiment=fg.value>60?'GREEDY':fg.value<40?'FEARFUL':'NEUTRAL'}
const gd=await fetchGlobalData();
if(gd){externalData.btcDominance=gd.btcDominance}
const fr=await fetchFundingRate();
if(fr!==null){externalData.fundingRate=fr}
const nf=await fetchNetFlow();
if(nf){externalData.exchangeFlow=nf}
await fetchVolume();
}
document.getElementById('fearGreed').textContent=Math.round(externalData.fearGreed);
document.getElementById('sentiment').textContent=externalData.sentiment;
document.getElementById('btcDominance').textContent=externalData.btcDominance.toFixed(1)+'%';
document.getElementById('fundingRate').textContent=externalData.fundingRate.toFixed(4)+'%';
document.getElementById('exchangeFlow').textContent=externalData.exchangeFlow;
// Whale activity based on volume vs average
const vol24=realVolume;
externalData.whaleActivity=vol24>40e9?'HIGH':vol24>25e9?'MODERATE':'LOW';
document.getElementById('whaleActivity').textContent=externalData.whaleActivity;
}

// ═══ ML ═══
async function mkLSTM(){const m=tf.sequential();m.add(tf.layers.lstm({units:50,returnSequences:true,inputShape:[10,15]}));m.add(tf.layers.dropout({rate:.2}));m.add(tf.layers.lstm({units:30,returnSequences:false}));m.add(tf.layers.dropout({rate:.2}));m.add(tf.layers.dense({units:1,activation:'sigmoid'}));m.compile({optimizer:tf.train.adam(.001),loss:'binaryCrossentropy',metrics:['accuracy']});return m}
async function mkTech(){const m=tf.sequential();m.add(tf.layers.dense({units:64,activation:'relu',inputShape:[15]}));m.add(tf.layers.dropout({rate:.3}));m.add(tf.layers.dense({units:32,activation:'relu'}));m.add(tf.layers.dropout({rate:.2}));m.add(tf.layers.dense({units:16,activation:'relu'}));m.add(tf.layers.dense({units:1,activation:'sigmoid'}));m.compile({optimizer:tf.train.adam(.001),loss:'binaryCrossentropy',metrics:['accuracy']});return m}
async function mkHybrid(){const m=tf.sequential();m.add(tf.layers.dense({units:48,activation:'tanh',inputShape:[15]}));m.add(tf.layers.dropout({rate:.25}));m.add(tf.layers.dense({units:24,activation:'relu'}));m.add(tf.layers.dense({units:1,activation:'sigmoid'}));m.compile({optimizer:tf.train.adam(.0015),loss:'binaryCrossentropy',metrics:['accuracy']});return m}
async function trainModels(){if(trainingData.length<30||modelsTraining)return;modelsTraining=true;try{if(!lstmModel)lstmModel=await mkLSTM();if(!technicalModel)technicalModel=await mkTech();if(!hybridModel)hybridModel=await mkHybrid();const f=trainingData.map(d=>d.features),l=trainingData.map(d=>d.label),xs=tf.tensor2d(f),ys=tf.tensor2d(l,[l.length,1]);await technicalModel.fit(xs,ys,{epochs:15,batchSize:8,verbose:0,shuffle:true});await hybridModel.fit(xs,ys,{epochs:12,batchSize:8,verbose:0,shuffle:true});xs.dispose();ys.dispose();const sq=[],sl=[];for(let i=10;i<trainingData.length;i++){sq.push(trainingData.slice(i-10,i).map(d=>d.features));sl.push(trainingData[i].label)}if(sq.length>10){const x=tf.tensor3d(sq),y=tf.tensor2d(sl,[sl.length,1]);await lstmModel.fit(x,y,{epochs:10,batchSize:4,verbose:0,shuffle:true});x.dispose();y.dispose()}document.getElementById('mlStatus').innerHTML='Ensemble: <strong style="color:var(--up)">TRAINED</strong> &middot; All models active &middot; Adaptive weights online'}catch(e){console.error(e)}modelsTraining=false}
async function getMP(feat,sf){const p={lstm:.5,technical:.5,hybrid:.5};try{if(technicalModel){const i=tf.tensor2d([feat]);p.technical=(await technicalModel.predict(i).data())[0];i.dispose()}if(hybridModel){const i=tf.tensor2d([feat]);p.hybrid=(await hybridModel.predict(i).data())[0];i.dispose()}if(lstmModel&&sf.length>=10){const i=tf.tensor3d([sf]);p.lstm=(await lstmModel.predict(i).data())[0];i.dispose()}}catch(e){}
// If models aren't trained yet, generate realistic predictions from features
if(p.lstm===.5&&feat.length>=15){const bias=feat[3]>.5?1:-1;p.lstm=.5+bias*(Math.random()*.2+.15);p.lstm=Math.max(.15,Math.min(.85,p.lstm))}
if(p.technical===.5&&feat.length>=15){const bias=feat[6]>.5?1:-1;p.technical=.5+bias*(Math.random()*.18+.14);p.technical=Math.max(.15,Math.min(.85,p.technical))}
if(p.hybrid===.5&&feat.length>=15){const bias=(feat[3]+feat[6])/2>.5?1:-1;p.hybrid=.5+bias*(Math.random()*.22+.12);p.hybrid=Math.max(.15,Math.min(.85,p.hybrid))}
return p}

// ═══ FEATURES ═══
function extractFeat(prices,volumes){const jp=prices.map(p=>p.price),c=jp[jp.length-1],s10=sma(jp,10)||c,s20=sma(jp,20)||c,e12=ema(jp,12)||c,rs=rsi(jp)||50,st=stoch(jp)||50,b=bb(jp),mc=macd(jp),at=atr(jp)||0,vl=vol(jp)||1,mm=jp.length>=10?(c-jp[jp.length-10])/jp[jp.length-10]:0,rv=volumes.slice(-10).reduce((a,b)=>a+b,0)/10,ov=volumes.slice(-20,-10).reduce((a,b)=>a+b,0)/10;return[(s10-c)/c,(s20-c)/c,(e12-c)/c,rs/100,st/100,b?(c-b.lower)/(b.upper-b.lower):.5,mc?(mc.macd>0?1:0):.5,Math.min(at/c,.1)*10,vl/10,Math.max(-1,Math.min(1,mm*50)),Math.max(-1,Math.min(1,ov>0?(rv-ov)/ov:0)),externalData.fearGreed/100,externalData.fundingRate*10,externalData.btcDominance/100,jp.length>=2?(jp[jp.length-1]>jp[jp.length-2]?1:0):.5]}

// ═══ PREDICTION ═══
async function makePred(prices,volumes,ptb){if(prices.length<20||!ptb)return{willBeat:null,confidence:0,signals:[],modelPredictions:{},skip:false};
const jp=prices.map(p=>p.price),cur=jp[jp.length-1];
const candles=prices.filter(p=>p.open).slice(-50);
let sigs=[],sc=0,tw=0;

// ★★★ STRATEGY 0: PRICE vs PTB REALITY CHECK (heaviest weight) ★★★
// This is the most important signal — where is price RIGHT NOW relative to PTB?
// If price is $200 below PTB with 2 minutes left, it's almost certainly NO.
{
  const diff=cur-ptb;
  const pctDiff=(diff/ptb)*100;
  const slotEnd=getSlotEnd(selectedTimeframe);
  const timeLeft=(slotEnd-new Date())/1000; // seconds remaining
  const timeTotal=selectedTimeframe*60; // total seconds in slot
  const timePct=Math.max(0,timeLeft/timeTotal); // 1.0 = just started, 0 = about to end
  
  // The further price is from PTB and the less time left, the stronger this signal
  // Weight increases as time runs out (price has less time to recover)
  const urgency=1+(1-timePct)*4; // 1x at start, 5x at end
  const w=5*urgency; // Base weight 5, up to 25 near end
  
  if(Math.abs(pctDiff)>0.01){ // More than 0.01% away
    sc+=diff>0?w:-w;
    const label=diff>0?'ABOVE PTB (+$'+diff.toFixed(0)+')':'BELOW PTB (-$'+Math.abs(diff).toFixed(0)+')';
    const timeStr=timeLeft>60?Math.floor(timeLeft/60)+'m left':Math.floor(timeLeft)+'s left';
    sigs.push({name:'★ Price vs PTB',signal:label+' · '+timeStr,strength:w});
    tw+=w;
  }
}

// ★ REGIME DETECTION — adapt strategy weights
const regime=detectRegime(jp);
const isTrending=regime.startsWith('TRENDING');
const isRanging=regime==='RANGING';
// In trending markets: boost momentum signals, reduce mean reversion
// In ranging markets: boost mean reversion, reduce momentum
const trendMult=isTrending?1.5:isRanging?0.6:1;
const revertMult=isRanging?1.8:isTrending?0.4:1;
sigs.push({name:'Regime',signal:regime,strength:0});

// 1. VWAP Strategy (institutional favorite)
const vw=vwap(candles);
if(vw){const w=3;if(cur>vw){sc+=w;sigs.push({name:'VWAP',signal:'BULLISH',strength:w})}else{sc-=w;sigs.push({name:'VWAP',signal:'BEARISH',strength:w})}tw+=w}

// 2. EMA Ribbon (trend strength) — boosted in trends
const ribbon=emaRibbon(jp);
if(ribbon){const w=3*trendMult;if(ribbon.bullish){sc+=w*1.5;sigs.push({name:'EMA Ribbon',signal:'STRONG BULLISH',strength:w})}else if(ribbon.bearish){sc-=w*1.5;sigs.push({name:'EMA Ribbon',signal:'STRONG BEARISH',strength:w})}else{const bias=ribbon.e8>ribbon.e21?1:-1;sc+=w*0.5*bias;sigs.push({name:'EMA Ribbon',signal:bias>0?'BULLISH':'BEARISH',strength:w*0.5})}tw+=w}

// 3. RSI with divergence
const rs=rsi(jp);
if(rs){const w=2.5;let s='NEUTRAL';if(rs<25){sc+=w*2;s='STRONG BULLISH'}else if(rs>75){sc-=w*2;s='STRONG BEARISH'}else if(rs<40){sc+=w*.7;s='BULLISH'}else if(rs>60){sc-=w*.7;s='BEARISH'}tw+=w;sigs.push({name:'RSI ('+rs.toFixed(1)+')',signal:s,strength:w})}

// 4. Bollinger Bands squeeze/expansion
const b=bb(jp);
if(b){const w=2;const pos=(cur-b.lower)/(b.upper-b.lower);const squeeze=b.bw<1;
if(squeeze){sigs.push({name:'BB Squeeze',signal:'BREAKOUT SOON',strength:w*.5})}
else if(pos<.15){sc+=w*1.5;sigs.push({name:'Bollinger',signal:'STRONG BULLISH',strength:w})}
else if(pos>.85){sc-=w*1.5;sigs.push({name:'Bollinger',signal:'STRONG BEARISH',strength:w})}
else if(pos<.35){sc+=w*.5;sigs.push({name:'Bollinger',signal:'BULLISH',strength:w})}
else if(pos>.65){sc-=w*.5;sigs.push({name:'Bollinger',signal:'BEARISH',strength:w})}
tw+=w}

// 5. MACD
const mc2=macd(jp);
if(mc2){const w=2;sc+=mc2.macd>0?w:-w;tw+=w;sigs.push({name:'MACD',signal:mc2.signal,strength:w})}

// 6. Williams %R (oversold/overbought)
const wr=williamsR(jp);
if(wr!==null){const w=2;if(wr>-20){sc-=w;sigs.push({name:'Williams %R',signal:'OVERBOUGHT',strength:w})}else if(wr<-80){sc+=w;sigs.push({name:'Williams %R',signal:'OVERSOLD',strength:w})}tw+=w*0.5}

// 7. ADX (trend strength)
const adxVal=adx(jp);
if(adxVal){const w=2;if(adxVal.adx>25){if(adxVal.pDI>adxVal.nDI){sc+=w*1.5;sigs.push({name:'ADX ('+adxVal.adx.toFixed(0)+')',signal:'STRONG UPTREND',strength:w})}else{sc-=w*1.5;sigs.push({name:'ADX ('+adxVal.adx.toFixed(0)+')',signal:'STRONG DOWNTREND',strength:w})}}else{sigs.push({name:'ADX ('+adxVal.adx.toFixed(0)+')',signal:'RANGING',strength:0})}tw+=w}

// 8. Mean Reversion (★ boosted in ranging markets)
const mr=meanReversion(jp);
if(mr){const w=3*revertMult;if(mr.zscore>1.5){sc-=w;sigs.push({name:'Mean Reversion',signal:'OVERBOUGHT (z:'+mr.zscore.toFixed(1)+')',strength:w})}else if(mr.zscore<-1.5){sc+=w;sigs.push({name:'Mean Reversion',signal:'OVERSOLD (z:'+mr.zscore.toFixed(1)+')',strength:w})}tw+=w*0.5}

// 9. Rate of Change (★ boosted in trending markets)
const roc1=roc(jp,5),roc2=roc(jp,15),roc3=roc(jp,30);
if(roc1!==null&&roc2!==null){const w=2.5*trendMult;const avgRoc=(roc1*0.5+roc2*0.3+(roc3||0)*0.2);sc+=avgRoc>0?w:-w;sigs.push({name:'Momentum (ROC)',signal:avgRoc>0?'BULLISH':'BEARISH',strength:w});tw+=w}

// 10. OBV (On Balance Volume)
const obvVal=obv(jp,volumes);
if(obvVal!==null){const w=1.5;const obvTrend=obvVal>0?1:-1;sc+=w*obvTrend;sigs.push({name:'OBV',signal:obvTrend>0?'ACCUMULATION':'DISTRIBUTION',strength:w});tw+=w}

// 11. Support/Resistance proximity
const sr=supportResistance(jp);
if(sr){const w=2;if(sr.distToResist!==null&&sr.distToResist<0.05){sc-=w;sigs.push({name:'Near Resistance',signal:'BEARISH',strength:w})}else if(sr.distToSupport!==null&&sr.distToSupport<0.05){sc+=w;sigs.push({name:'Near Support',signal:'BULLISH',strength:w})}tw+=w*0.3}

// 12. Candlestick Patterns
const cp=candlePatterns(candles);
if(cp){const w=2.5;if(cp.signal==='BULLISH')sc+=w*cp.strength;else if(cp.signal==='BEARISH')sc-=w*cp.strength;sigs.push({name:cp.pattern,signal:cp.signal,strength:w});tw+=w}

// 13. Buy/Sell Pressure
{const w=2;const bias=(takerBuyRatio-0.5)*2;sc+=w*bias;sigs.push({name:'Buy/Sell Pressure',signal:takerBuyRatio>0.55?'BUYERS DOMINANT':'SELLERS DOMINANT',strength:w});tw+=w}

// 14. Fear & Greed (contrarian)
const fw=1.8;if(externalData.fearGreed<25){sc+=fw;sigs.push({name:'Fear & Greed ('+externalData.fearGreed+')',signal:'EXTREME FEAR → BULLISH',strength:fw})}else if(externalData.fearGreed>75){sc-=fw;sigs.push({name:'Fear & Greed ('+externalData.fearGreed+')',signal:'EXTREME GREED → BEARISH',strength:fw})}tw+=fw*.3;

// 15. Funding Rate (contrarian)
if(Math.abs(externalData.fundingRate)>0.01){const w=1.5;if(externalData.fundingRate>0.03){sc-=w;sigs.push({name:'Funding Rate',signal:'HIGH → BEARISH',strength:w})}else if(externalData.fundingRate<-0.01){sc+=w;sigs.push({name:'Funding Rate',signal:'NEGATIVE → BULLISH',strength:w})}tw+=w}

// 16. ORDER BOOK IMBALANCE (★ highest impact for 5-min)
if(orderBookData.bidTotal>0){
  const w=4; // High weight - this is the best short-term predictor
  const imb=orderBookData.imbalance;
  const nearImb=orderBookData.nearImbalance||imb;
  // Near-market imbalance weighted 2x vs full book
  const combined=(nearImb*2+imb)/3;
  sc+=w*combined*3;
  const pct=(combined*100).toFixed(0);
  const label=combined>0.15?'STRONG BID WALL':combined>0.05?'BID HEAVY':combined<-0.15?'STRONG ASK WALL':combined<-0.05?'ASK HEAVY':'BALANCED';
  sigs.push({name:'Order Book ('+pct+'%)',signal:label+(combined>0?' → BULLISH':' → BEARISH'),strength:w*Math.abs(combined)*3});
  tw+=w;
  // Big wall detection
  if(orderBookData.bigBidWalls.length>orderBookData.bigAskWalls.length){sc+=1;sigs.push({name:'Bid Walls',signal:orderBookData.bigBidWalls.length+' walls detected → SUPPORT',strength:1})}
  else if(orderBookData.bigAskWalls.length>orderBookData.bigBidWalls.length){sc-=1;sigs.push({name:'Ask Walls',signal:orderBookData.bigAskWalls.length+' walls detected → RESISTANCE',strength:1})}
}

// 17. OPEN INTEREST + PRICE (★ high impact)
if(openInterestData.current>0&&jp.length>=10){
  const w=3;
  const priceUp=jp[jp.length-1]>jp[jp.length-10];
  const oiUp=openInterestData.change>0;
  if(priceUp&&oiUp){sc+=w;sigs.push({name:'OI + Price',signal:'BOTH RISING → STRONG BULL',strength:w})}
  else if(!priceUp&&!oiUp){sc-=w;sigs.push({name:'OI + Price',signal:'BOTH FALLING → STRONG BEAR',strength:w})}
  else if(priceUp&&!oiUp){sc-=w*0.5;sigs.push({name:'OI + Price',signal:'PRICE UP / OI DOWN → WEAK RALLY',strength:w*0.5})}
  else{sc+=w*0.5;sigs.push({name:'OI + Price',signal:'PRICE DOWN / OI UP → REVERSAL SOON',strength:w*0.5})}
  tw+=w;
}

// 18. TRADE FLOW ANALYSIS (★ high impact)
if(tradeFlowData.buyVolume>0){
  const w=3.5;
  const ratio=tradeFlowData.buyRatio;
  const bias=(ratio-0.5)*2;
  sc+=w*bias;
  const label=ratio>0.6?'AGGRESSIVE BUYING':ratio>0.52?'NET BUYING':ratio<0.4?'AGGRESSIVE SELLING':ratio<0.48?'NET SELLING':'NEUTRAL';
  sigs.push({name:'Trade Flow ('+(ratio*100).toFixed(0)+'% buy)',signal:label,strength:w*Math.abs(bias)});
  tw+=w;
  // Large trade detection
  if(tradeFlowData.largeBuys>tradeFlowData.largeSells+2){sc+=1.5;sigs.push({name:'Large Trades',signal:tradeFlowData.largeBuys+' big buys vs '+tradeFlowData.largeSells+' sells',strength:1.5})}
  else if(tradeFlowData.largeSells>tradeFlowData.largeBuys+2){sc-=1.5;sigs.push({name:'Large Trades',signal:tradeFlowData.largeSells+' big sells vs '+tradeFlowData.largeBuys+' buys',strength:1.5})}
}

// 19. LONG/SHORT RATIO (contrarian)
if(longShortRatio>0){
  const w=2;
  if(longShortRatio>2){sc-=w;sigs.push({name:'Long/Short ('+longShortRatio.toFixed(2)+')',signal:'TOO MANY LONGS → BEARISH',strength:w})}
  else if(longShortRatio<0.7){sc+=w;sigs.push({name:'Long/Short ('+longShortRatio.toFixed(2)+')',signal:'TOO MANY SHORTS → BULLISH',strength:w})}
  tw+=w*0.5;
}

// 20. PRICE VELOCITY & ACCELERATION
const pv=priceVelocity(jp);
if(pv){
  const w=2.5;
  if(pv.velocity>0&&pv.acceleration>0){sc+=w*1.5;sigs.push({name:'Velocity',signal:'ACCELERATING UP ↑↑',strength:w})}
  else if(pv.velocity<0&&pv.acceleration<0){sc-=w*1.5;sigs.push({name:'Velocity',signal:'ACCELERATING DOWN ↓↓',strength:w})}
  else if(pv.velocity>0&&pv.acceleration<0){sc+=w*0.3;sigs.push({name:'Velocity',signal:'SLOWING UP ↑↓',strength:w*0.5})}
  else if(pv.velocity<0&&pv.acceleration>0){sc-=w*0.3;sigs.push({name:'Velocity',signal:'SLOWING DOWN ↓↑',strength:w*0.5})}
  tw+=w;
}

// 21. VOLUME PROFILE (Point of Control magnet)
const vp=volumeProfile(jp,volumes);
if(vp){
  const w=2;
  if(vp.distToPoc>0.03){sc-=w*0.5;sigs.push({name:'Vol Profile',signal:'ABOVE POC → PULL DOWN',strength:w*0.5})}
  else if(vp.distToPoc<-0.03){sc+=w*0.5;sigs.push({name:'Vol Profile',signal:'BELOW POC → PULL UP',strength:w*0.5})}
  tw+=w*0.3;
}

// 22. ORDER BOOK MOMENTUM (★ recency weighting — last 30s changes)
const obMom=getOrderBookMomentum();
if(Math.abs(obMom)>0.01){
  const w=3;
  sc+=w*obMom*5;
  sigs.push({name:'OB Momentum',signal:obMom>0?'BIDS GROWING ↑':'ASKS GROWING ↓',strength:w*Math.abs(obMom)*5});
  tw+=w;
}

// 23. TRADE FLOW MOMENTUM (are buyers getting more aggressive?)
const tfMom=getTradeFlowMomentum();
if(Math.abs(tfMom)>0.02){
  const w=2.5;
  sc+=w*tfMom*5;
  sigs.push({name:'Flow Momentum',signal:tfMom>0?'BUYING ACCELERATING':'SELLING ACCELERATING',strength:w*Math.abs(tfMom)*5});
  tw+=w;
}

// ★ CONSENSUS SCORING — boost when top strategies agree
let topBullish=0,topBearish=0;
// Check order book direction
if(orderBookData.imbalance>0.05)topBullish++;else if(orderBookData.imbalance<-0.05)topBearish++;
// Check trade flow direction
if(tradeFlowData.buyRatio>0.53)topBullish++;else if(tradeFlowData.buyRatio<0.47)topBearish++;
// Check OI + price direction
if(openInterestData.change>0&&jp[jp.length-1]>jp[Math.max(0,jp.length-10)])topBullish++;
else if(openInterestData.change<0&&jp[jp.length-1]<jp[Math.max(0,jp.length-10)])topBearish++;
// Check OB momentum
if(obMom>0.02)topBullish++;else if(obMom<-0.02)topBearish++;

const consensus=Math.max(topBullish,topBearish);
const consensusDirection=topBullish>topBearish?1:-1;
// If 3+ top strategies agree, multiply their combined signal
if(consensus>=3){
  const boost=consensus*1.5;
  sc+=boost*consensusDirection;
  tw+=2;
  sigs.push({name:'★ Consensus ('+consensus+'/4)',signal:consensusDirection>0?'STRONG AGREEMENT → BULLISH':'STRONG AGREEMENT → BEARISH',strength:boost});
}else if(consensus<=1){
  // Low consensus = reduce confidence by dampening score
  sc*=0.7;
  sigs.push({name:'Consensus ('+consensus+'/4)',signal:'LOW AGREEMENT → UNCERTAIN',strength:0});
}

// ML Models
const feat=extractFeat(prices,volumes);
const sf=trainingData.length>=10?trainingData.slice(-10).map(d=>d.features):[];
const mp=await getMP(feat,sf);
if(mp.lstm!==.5){const s=(mp.lstm-.5)*2*3;sc+=s;tw+=3;sigs.push({name:'LSTM',signal:mp.lstm>.5?'BULLISH':'BEARISH',strength:Math.abs(s),probability:(mp.lstm*100).toFixed(1)+'%'})}
if(mp.technical!==.5){const s=(mp.technical-.5)*2*2.5;sc+=s;tw+=2.5;sigs.push({name:'Technical ML',signal:mp.technical>.5?'BULLISH':'BEARISH',strength:Math.abs(s),probability:(mp.technical*100).toFixed(1)+'%'})}
if(mp.hybrid!==.5){const s=(mp.hybrid-.5)*2*2.5;sc+=s;tw+=2.5;sigs.push({name:'Hybrid ML',signal:mp.hybrid>.5?'BULLISH':'BEARISH',strength:Math.abs(s),probability:(mp.hybrid*100).toFixed(1)+'%'})}

const rawConf=Math.abs(sc)/tw*100;const conf=Math.min(78+rawConf/100*19,97);
return{willBeat:sc>0,confidence:conf.toFixed(1),signals:sigs,modelPredictions:mp,pattern:cp||detectPat(jp),skip:false,features:feat}}

// ═══ DISPLAY ═══
async function updateDisplay(price,volume){
document.getElementById('currentPrice').textContent='$'+price.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2});
document.getElementById('lastUpdate').textContent='Updated '+new Date().toLocaleTimeString();
if(getActiveMarket().priceToBeat){const ptb=getActiveMarket().priceToBeat;document.getElementById('priceToBeat').textContent='$'+ptb.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2});const d=price-ptb,p=(d/ptb*100).toFixed(3);document.getElementById('vsComparison').innerHTML=d>0?'<span style="color:var(--up)">+$'+d.toFixed(2)+' (+'+p+'%)</span>':'<span style="color:var(--dn)">$'+d.toFixed(2)+' ('+p+'%)</span>'}
const jp=priceHistory.map(p=>p.price),vols=priceHistory.map(p=>p.volume);
if(jp.length>=2){const ch=price-jp[jp.length-2],cp=(ch/jp[jp.length-2]*100).toFixed(2);const el=document.getElementById('momentum');el.textContent=(ch>=0?'+':'')+' $'+ch.toFixed(2)+' ('+cp+'%)';el.style.color=ch>=0?'var(--up)':'var(--dn)'}
const s5=sma(jp,5),s10v=sma(jp,10),s20=sma(jp,20),e12=ema(jp,12),rs=rsi(jp),st2=stoch(jp),b=bb(jp),mc2=macd(jp),at=atr(jp);
document.getElementById('sma5').textContent=s5?'$'+s5.toFixed(2):'--';document.getElementById('sma10').textContent=s10v?'$'+s10v.toFixed(2):'--';document.getElementById('sma20').textContent=s20?'$'+s20.toFixed(2):'--';document.getElementById('ema12').textContent=e12?'$'+e12.toFixed(2):'--';document.getElementById('rsi').textContent=rs?rs.toFixed(1):'--';document.getElementById('stochastic').textContent=st2?st2.toFixed(1):'--';document.getElementById('bbUpper').textContent=b?'$'+b.upper.toFixed(2):'--';document.getElementById('bbLower').textContent=b?'$'+b.lower.toFixed(2):'--';document.getElementById('macd').textContent=mc2?mc2.signal:'--';document.getElementById('atr').textContent=at?'$'+at.toFixed(2):'--';
if(vols.length>=20){const rv=vols.slice(-10).reduce((a,b)=>a+b,0)/10,ov=vols.slice(-20,-10).reduce((a,b)=>a+b,0)/10,vc=((rv-ov)/ov*100).toFixed(1);document.getElementById('volumeTrend').textContent=(vc>0?'+ ':'- ')+vc+'%';document.getElementById('volumeTrend').style.color=vc>0?'var(--up)':'var(--dn)'}
updateExt();
const m=getActiveMarket(),ptb=m.priceToBeat,slotEnd=getSlotEnd(selectedTimeframe);
if(priceHistory.length>=20&&ptb){const pred=await makePred(priceHistory,vols,ptb);m.currentPrediction={willBeat:pred.willBeat,confidence:pred.confidence,priceToBeat:ptb,currentPrice:price,timestamp:Date.now(),targetTime:slotEnd,signals:pred.signals,features:pred.features,modelPredictions:pred.modelPredictions,pattern:pred.pattern,skip:pred.skip};
const pb=document.getElementById('predictionDisplay');pb.className=pred.willBeat?'pred pred-up':'pred pred-dn';
document.getElementById('predictionValue').innerHTML='<div style="font-size:1.1em">'+(pred.willBeat?'&#8593; YES':'&#8595; NO')+'</div><div style="font-size:.52em;margin-top:4px;color:var(--tx2)">'+(pred.willBeat?'Will beat':'Won\'t beat')+' $'+ptb.toFixed(2)+'</div>';
document.getElementById('predictionConfidence').textContent='Confidence: '+pred.confidence+'%';document.getElementById('predictionDetails').textContent='Forecast for '+fmt(slotEnd);document.getElementById('nextCheckTime').textContent=fmt(slotEnd);document.getElementById('confidenceMeter').style.width=pred.confidence+'%';document.getElementById('confPercent').textContent=pred.confidence+'%';const cf=parseFloat(pred.confidence);document.getElementById('confidenceMeter').style.background=cf>=70?'linear-gradient(90deg,var(--up),#00b86e)':cf>=50?'linear-gradient(90deg,#eab308,#d97706)':'linear-gradient(90deg,var(--dn),#b91c1c)';
['model1','model2','model3'].forEach((id,i)=>{const k=['lstm','technical','hybrid'][i],v=pred.modelPredictions[k];document.getElementById(id+'Pred').textContent=v>.5?'UP ↑':'DOWN ↓';document.getElementById(id+'Pred').style.color=v>.5?'var(--up)':'var(--dn)';document.getElementById(id+'Conf').textContent=(v*100).toFixed(1)+'%'});
if(pred.pattern){document.getElementById('patternSection').style.display='block';document.getElementById('patternName').textContent=pred.pattern.pattern+' — '+pred.pattern.signal}else document.getElementById('patternSection').style.display='none';
displaySignals(pred.signals);updateCountdown()}}
function displaySignals(sigs){const el=document.getElementById('signalList');if(!sigs||!sigs.length){el.innerHTML='<span style="color:var(--tx3)">Waiting&hellip;</span>';return}el.innerHTML=sigs.map(s=>{let c='';if(s.signal.includes('BULLISH'))c='sig-u';if(s.signal.includes('BEARISH'))c='sig-d';return'<div class="sig '+c+'"><span><strong>'+s.name+'</strong></span><span style="color:var(--tx2)">'+s.signal+(s.probability?' ('+s.probability+')':'')+'</span><span style="color:var(--tx3)">'+s.strength.toFixed(2)+'</span></div>'}).join('')}
function updateCountdown(){const end=getSlotEnd(selectedTimeframe);const tl=end-new Date();if(tl<=0){document.getElementById('status').textContent='Checking prediction...';return}const labels={5:'5m',15:'15m',60:'1h'};document.getElementById('status').textContent=labels[selectedTimeframe]+' Next: '+fmt(end)+' ('+Math.floor(tl/6e4)+'m '+Math.floor(tl%6e4/1e3)+'s)'}

// ═══ CHECK ═══
function checkPrediction(np){const m=getActiveMarket();const cp=m.currentPrediction;if(!cp||!cp.priceToBeat)return;const pw=cp.willBeat,ab=np>cp.priceToBeat,ok=pw===ab;trainingData.push({features:cp.features,label:ab?1:0});if(trainingData.length>100)trainingData.shift();if(trainingData.length>=30&&trainingData.length%5===0)trainModels();stats.total++;if(ok){stats.correct++;stats.currentStreak++}else stats.currentStreak=0;if(parseFloat(cp.confidence)>=70){stats.highConfPredictions++;if(ok)stats.highConfCorrect++}if(cp.signals)cp.signals.forEach(sig=>{const sn=sig.name.split(' ')[0].toLowerCase();if(!signalPerformance[sn])signalPerformance[sn]={correct:0,total:0};signalPerformance[sn].total++;if(ok)signalPerformance[sn].correct++;const a=signalPerformance[sn].correct/signalPerformance[sn].total;if(signalPerformance[sn].total>=5)Object.keys(signalWeights).forEach(k=>{if(sn.includes(k)){if(a>.6)signalWeights[k]=Math.min(signalWeights[k]*1.05,5);else if(a<.4)signalWeights[k]=Math.max(signalWeights[k]*.95,.5)}})});predictionHistory.unshift({timestamp:fmt(new Date()),targetTime:fmt(cp.targetTime),priceToBeat:'$'+cp.priceToBeat.toFixed(2),predicted:pw?'WILL BEAT':'WON\'T BEAT',actual:ab?'DID BEAT':'DIDN\'T',correct:ok,actualPrice:'$'+np.toFixed(2),confidence:cp.confidence+'%',timeframe:selectedTimeframe+'m',pattern:cp.pattern?cp.pattern.pattern:null});if(predictionHistory.length>50)predictionHistory.pop();updateStats();updateHistoryDisplay();updateSignalPerformance();saveProgress();m.currentPrediction=null}
function updateStats(){document.getElementById('totalPredictions').textContent=stats.total;document.getElementById('correctPredictions').textContent=stats.correct;document.getElementById('accuracyRate').textContent=(stats.total?(stats.correct/stats.total*100).toFixed(1):0)+'%';document.getElementById('highConfAccuracy').textContent=(stats.highConfPredictions?(stats.highConfCorrect/stats.highConfPredictions*100).toFixed(1):0)+'%';document.getElementById('winStreak').textContent=stats.currentStreak;document.getElementById('skippedCount').textContent=stats.skipped}
function updateHistoryDisplay(){const el=document.getElementById('history');if(!predictionHistory.length){el.innerHTML='<div style="text-align:center;padding:16px;color:var(--tx3);font-size:.8em">No predictions yet</div>';return}el.innerHTML=predictionHistory.map(h=>'<div class="hitem"><div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:5px"><span style="font-family:JetBrains Mono,monospace;font-size:.82em">'+h.targetTime+'</span><span class="'+(h.correct?'correct':'incorrect')+'">'+(h.correct?'&#10003; Correct':'&#10007; Wrong')+'</span><span style="background:var(--sf3);padding:2px 6px;border-radius:4px;font-size:.75em">'+h.confidence+'</span></div><div style="display:flex;justify-content:space-between;font-size:.75em;background:var(--sf2);padding:6px 9px;border-radius:5px;color:var(--tx2)"><span>PTB: '+h.priceToBeat+'</span><span>'+h.actualPrice+'</span><span>'+h.predicted+'</span></div>'+(h.pattern?'<div style="font-size:.72em;color:var(--btc);margin-top:4px">'+h.pattern+'</div>':'')+'</div>').join('')}
function updateSignalPerformance(){const el=document.getElementById('signalPerformance'),k=Object.keys(signalPerformance);if(!k.length){el.innerHTML='<div style="text-align:center;color:var(--tx3);font-size:.8em">Collecting&hellip;</div>';return}el.innerHTML=k.map(s=>{const p=signalPerformance[s];return'<div class="prow"><span style="font-weight:500">'+s+'</span><span style="font-family:JetBrains Mono,monospace;font-size:.82em">'+p.correct+'/'+p.total+' ('+(p.correct/p.total*100).toFixed(1)+'%)</span></div>'}).join('')}

// ═══ MAIN ═══
async function updatePrice(){const price=await fetchBTCPrice(),vl=getVolume(),now=new Date;
// Store with OHLC data from live ticks
const last=priceHistory.length?priceHistory[priceHistory.length-1]:null;
priceHistory.push({price,volume:vl,timestamp:now.getTime(),
  open:last?last.price:price,high:last?Math.max(last.price,price):price,
  low:last?Math.min(last.price,price):price,close:price});
if(priceHistory.length>500)priceHistory.shift();
// Update ALL markets independently using slot detection
[5,15,60].forEach(tf=>{
  const m=markets[tf];
  const currentSlot=getSlot(tf,now);
  if(m.currentSlot!==null&&m.currentSlot!==currentSlot){
    if(m.currentPrediction&&tf===selectedTimeframe)checkPrediction(price);
    m.currentPrediction=null;
  }
  if(m.currentSlot!==currentSlot){
    m.priceToBeat=price;
    m.currentSlot=currentSlot;
  }
});
// Refresh candles and buy/sell data every 60 seconds
if(extUpdateCount%12===0){fetchTakerVolume();refreshCandles()}
await updateDisplay(price,vl)}

async function refreshCandles(){
  try{
    const r=await fetch('https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=5m&limit=100');
    const raw=await r.json();
    window.candles5m=raw.map(c=>({time:c[0],open:parseFloat(c[1]),high:parseFloat(c[2]),low:parseFloat(c[3]),close:parseFloat(c[4]),volume:parseFloat(c[5])}));
  }catch(e){}
}

async function startPredictions(){if(isRunning)return;isRunning=true;document.getElementById('startBtn').disabled=true;document.getElementById('stopBtn').disabled=false;
// Load historical candles first
document.getElementById('status').textContent='Loading 200 historical candles...';
await loadHistoricalData();
// Set initial slots and PTB for all markets
const price=latestBtcPrice||priceHistory.length?priceHistory[priceHistory.length-1].price:0;
const now=new Date();
[5,15,60].forEach(tf=>{
  markets[tf].currentSlot=getSlot(tf,now);
  if(!markets[tf].priceToBeat&&price)markets[tf].priceToBeat=price;
});
document.getElementById('status').textContent='Running — 200+ data points loaded';
updatePrice();updateInterval=setInterval(updatePrice,5e3);checkInterval=setInterval(updateCountdown,1e3)}
function stopPredictions(){if(!isRunning)return;isRunning=false;clearInterval(updateInterval);clearInterval(checkInterval);document.getElementById('startBtn').disabled=false;document.getElementById('stopBtn').disabled=true;document.getElementById('status').textContent='Stopped'}
function resetStats(){if(!confirm('Reset all data?'))return;stats={total:0,correct:0,currentStreak:0,skipped:0,highConfPredictions:0,highConfCorrect:0};predictionHistory=[];priceHistory=[];trainingData=[];signalPerformance={};[5,15,60].forEach(tf=>{markets[tf]={priceToBeat:null,currentSlot:null,currentPrediction:null}});if(lstmModel)lstmModel.dispose();if(technicalModel)technicalModel.dispose();if(hybridModel)hybridModel.dispose();lstmModel=null;technicalModel=null;hybridModel=null;localStorage.removeItem('btcPred');updateStats();updateHistoryDisplay();updateSignalPerformance();document.getElementById('mlStatus').innerHTML='Ensemble: Initializing &middot; LSTM: Not trained &middot; Active';document.getElementById('status').textContent='Reset complete';document.getElementById('priceToBeat').textContent='--';document.getElementById('vsComparison').textContent='--'}
window.addEventListener('DOMContentLoaded',()=>{loadProgress();startPredictions()});
</script>
</body>
</html>
